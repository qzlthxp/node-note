# 文件读写

## 同步读取文件

1. 引入 `fs` 模块

   ```js
   const fs = require('fs')
   ```

2. 使用 `fs` 的 `readFileSync` 方法读取文件内容

   ```js
   const textIn = fs.readFileSync(/*需要读取文件的地址*/, /*文件编码 例如 utf-8*/)
   ```

## 同步写入文件

1. 同样的引入 `fs` 模块

   ```js
   const fs = require('fs')
   ```

2. 使用 `fs` 模块的 `writeFileSync` 方法

   ```js
   const textOut = `Created on ${Date.now()}`
   fs.writeFileSync(/*需要写入内容的文件地址，文件不存在会创建*/, textOut/*需要写入的内容*/)
   ```

解决同步阻塞问题，使用异步方法。解决回调地狱（callback hell），使用 `Promise` 或者 `async/await`

## 异步读取文件

1. 引入 `fs` 模块

   ```js
   const fs = require('fs')
   ```

2. 使用 `fs` 的 `readFile` 方法

   ```js
   fs.readFile(
     /*读取文件的地址*/
     './txt/start.txt',
     /*文件编码*/
     'utf-8',
     /*回调，处理错误和读取内容*/
     (err, data) => {
       if (err) return 
       console.log(data)
     }
   )
   ```

## 异步写入文件

1. 引入 `fs` 模块

   ```js
   const fs = require('fs')
   ```

2. 使用 `fs` 的 `writeFile` 方法

   ```js
   const text = 'Create on' + Date.now()
   fs.writeFile(
     /*需要写入的文件地址*/
     './txt/final.txt',
     /*写入内容*/
     text,
     /*文件编码*/
     'utf-8',
     /*回调处理异常，没有异常也会调用*/
     err => {
       if (err) return console.log(err)
     }
   )
   ```

## 完整demo

```js
const fs = require('fs')

const textIn = fs.readFileSync('./txt/input.txt', 'utf-8')
console.log(textIn)

const textOut = `This is what we know about the avocado: ${textIn}.\nCreated on ${Date.now()}`
fs.writeFileSync('./txt/output.txt', textOut)
console.log('File written!')
```

```js
const fs = require('fs')

fs.readFile('./txt/start.txt', 'utf-8', (err, data1) => {
  if (err) {
    throw err
  }

  fs.readFile(`./txt/${data1}.txt`, 'utf-8', (err, data2) => {
    console.log(data2)
    fs.readFile(`./txt/append.txt`, 'utf-8', (err, data3) => {
      console.log(data3)

      fs.writeFile('./txt/final.txt', `${data2}\n${data3}`, 'utf-8', (err) => {
        if (err) return console.log(err)
        console.log('Your file has been written😁')
      })
    })
  })
})

console.log('Reading File...')
```

